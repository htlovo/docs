1.值类型转换
	将值从一种类型转换为另一种类型通常称为类型转换（type casting ），这是显式的情况；隐式的情况称为强制类型转换（coercion）。
	也可以这样来区分：类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）。
	然而在JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion ）和“显式强制类型转换”（explicit coercion ）来区分。
	JavaScript 中的强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数。
2.抽象值操作
	1.ToString
		转换规则如下：
			如果是Boolean值，true 和false 将分别被转换为"true"和"false"。 
			如果是数字值，返回数字的字符串形式
			如果是字符串，只是简单的传入和返回。
			如果是null，则返回"null" ； 
			如果是undefined，则返回"undefined"；
			如果是对象，则对其进行到字符串的ToPrimitive抽象操作并将返回值转换为字符串

		JSON 字符串化
			...
	2.ToNumber
		转换规则如下：
			如果是Boolean值，true 和false 将分别被转换为1 和0。 
			如果是数字值，只是简单的传入和返回。 
			如果是null 值，返回0。 
			如果是undefined，返回NaN 。 
			如果是字符串，遵循下列规则： 
				如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成1，"123"会变成123 ，而"011" 会变成11 （注意：前导的零被忽略了）； 
				如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）； 
				如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
				如果字符串中包含"0x"和"." ，则将其转换为NaN 。
				如果字符串是空的或只包含空格，则将其转换为0； 
				如果字符串中包含除上述格式之外的字符，则将其转换为NaN 。
			如果是对象，则对其进行到数字的ToPrimitive抽象操作并将返回值转换为数字
		从ES5 开始，使用Object.create(null) 创建的对象[[Prototype]] 属性为null，并且没有valueOf() 和toString()方法，因此无法进行强制类型转换。
	3.ToBoolean
		假值的布尔强制类型转换结果为false,这些是假值：
			undefined
			null
			false
			+0、-0和NaN
			""
		假值以外的值，包括所有对象，都是真值
		假值对象：
			浏览器在某些特定情况下，在常规JavaScript 语法基础上自己创建了一些外来（exotic）值，这些就是“假值对象”。
			假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false。
			最常见的例子是document.all，它是一个类数组对象，包含了页面上的所有元素，由DOM（而不是JavaScript 引擎）提供给JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为true，不过现在它是一个假值对象。
			document.all并不是一个标准用法，早就被废止了。
3.显式强制类型转换
	1.字符串和数字之间的显式转换
		字符串和数字之间的转换可通过String(..)和Number(..)这两个内建函数来实现。
		String(..)遵循ToString规则。Number(..)遵循ToNumber规则。
		toString()是显式的，不过其中涉及隐式转换。因为toString()对42这样的基本类型值不适用，所以JavaScript 引擎会自动为42创建一个封装对象，然后对该对象调用toString()。
		一元加操作符的操作与Number() 函数相同。
		1. 日期显式转换为数字
			...
		2. 奇特的~ 运算符
			...
		3. 字位截除
			...
	2.显式解析数字字符串
		parseInt() 函数，返回十进制整数
			如果操作数不是字符串，则先对其进行ToString抽象操作，再进行转换
			在转换时，会忽略字符串前面的空格，直至找到第一个非空格字符。
			如果第一个非空格字符不是数字字符或者负号，parseInt()就会返回NaN ；
			用parseInt() 转换空字串或只包含空格的字符串会返回NaN 。
			如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。 
			如果字符串以"0x"开头且后跟数字字符，就会将其当作一个十六进制整数，返回对应的十进制数值 
		可以为parseInt()函数提供第二个参数：转换时使用的基数（即多少进制）
		ES5 之前的parseInt(..)如果没有第二个参数来指定转换的基数（又称为radix），parseInt(..)会根据字符串的第一个字符来自行决定基数。如果第一个字符是x 或X，则转换为十六进制数字。如果是0，则转换为八进制数字。
		从ES5 开始parseInt(..)默认转换为十进制数，除非另外指定或字符串以"0x"开头。
		如果你的代码需要在ES5之前的环境运行，应将第二个参数设置为10。
		
		parseFloat(..)函数与parseInt()函数的区别：
			可识别第一个小数点以及科学计数法以解析并返回浮点数，遇到第二个小数点会被认为无效的浮点数字字符而停止解析；
			如果第一个非空格字符不是数字字符或者负号或"."，parseInt()就会返回NaN ；
			不支持第二个参数，不识别十六进制

	3.显示转换为布尔值
		Boolean(..)是显式的ToBoolean 强制类型转换
		在if(..)..这样的布尔值上下文中，如果没有使用Boolean(..) 和!!，就会自动隐式地进行ToBoolean 转换。建议使用Boolean(..) 和!!来进行显式转换以便让代码更清晰易读。
4.隐式强制类型转换
	隐式强制类型转换的作用是减少冗余，让代码更简洁。
	1.隐式地简化
	2.字符串和数字之间的隐式强制类型转换
		二元+操作符，两个操作符中如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive 抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文。
		如果+ 的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。
		我们可以将数字和空字符串 ""相+ 来将其转换为字符串，a  + ""（隐式）和前面的String(a)（显式）之间有一个差别：
		a  + ""会对a 调用valueOf() 方法，然后通过ToString抽象操作将返回值转换为字符串。而String(a) 则是直接调用ToString()。
		- 是数字减法运算符，因此a  -  0会将a 强制类型转换为数字。为了执行减法运算，a 和b 都需要被转换为数字，它们首先被转换为字符串（通过toString()），然后再转换为数字。
	3.布尔值到数字的隐式强制类型转换
	4.隐式强制类型转换为布尔值
		以下情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的ToBoolean 抽
		象操作规则。
		(1)  if (..) 语句中的条件判断表达式。
		(2)  for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）。
		(3)  while (..)和do..while(..) 循环中的条件判断表达式。
		(4)  ? : 中的条件判断表达式。
		(5)  逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。
	5.||和&&
		||和&&首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行ToBoolean 强制类型转换，然后再执行条件判断。
		对于||来说，如果条件判断结果为 true就返回第一个操作数的值，如果为false 就返回第二个操作数的值。
		&&则相反，如果条件判断结果为true就返回第二个操作数的值，如果为false 就返回第一个操作数的值。
	6.符号的强制类型转换
		...
5.宽松相等和严格相等
	宽松相等==和严格相等=== 都用来判断两个值是否“相等”，==允许在相等比较中进行强制类型转换，而=== 不允许。如果进行比较的两个值类型相同，则==和=== 使用相同的算法
	1.相等比较操作的性能
		实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已
		如果进行比较的两个值类型相同，则==和=== 使用相同的算法
		如果两个值的类型不同，就考虑有没有强制类型转换的必要，有就用==，没有就用===，不用在乎性能。
		==和=== 都会检查操作数的类型。操作数类型不同时它们的处理方式不同。
	2.抽象相等
		如果两个值的类型相同时，
			仅比较它们是否相等。不进行类型转换
			特别的，NaN不等于NaN，+0等于-0
			两个对象指向同一个值时即视为相等，不发生强制类型转换。
		如果两个值的类型不相同时，
			===会返回false。
			==会发生隐式强制类型转换，会将其中之一或两者都转换为相同的类型后再进行比较：
				NaN和任何值都不相等
				null，undefined两者相等并且与自身相等，但不与其他任何值相等，
				操作数中有一个对象时，对对象进行到数字的ToPrimitive()操作，
				操作数中有一个是数字或布尔值时，都转化为数字进行比较

	3.比较少见的情况
		1. 返回其他数字
			内置原生原型被更改导致的奇怪结果
			我们应该正确合理地运用强制类型转换，避免这些极端的情况。
		2.假值的相等比较
			"0" == null;           // false 
			"0" == undefined;      // false 
			"0" == false;          // true -- 晕！ 
			"0" == NaN;            // false 
			"0" == 0;              // true 
			"0" == "";             // false 
			 
			false == null;         // false 
			false == undefined;    // false 
			false == NaN;          // false 
			false == 0;            // true -- 晕！ 
			false == "";           // true -- 晕！ 
			false == [];           // true -- 晕！ 
			false == {};           // false 
			 
			"" == null;            // false 
			"" == undefined;       // false 
			"" == NaN;             // false 
			"" == 0;               // true -- 晕！ 
			"" == [];              // true -- 晕！ 
			"" == {};              // false 
			 
			0 == null;             // false 
			0 == undefined;        // false 
			0 == NaN;              // false 
			0 == [];               // true -- 晕！ 
			0 == {};               // false
		3. 极端情况
			[] == ![]   // true
			...
		4. 完整性检查
			前面列举了相等比较中的强制类型转换的7 个坑
			其中有4 种情况涉及== false，我们应该避免。
			我们应该不太可能会用==  [] 来做条件判断，而是用== ""或者== 0
			这些特殊情况会导致各种问题，应多加小心
		5. 安全运用隐式强制类型转换
			我们要对==两边的值认真推敲，以下两个原则可以让我们有效地避免出错。
			•  如果两边的值中有true或者false，千万不要使用==。
			•  如果两边的值中有[]、""或者0，尽量不要使用==。
			这时最好用=== 来避免不经意的强制类型转换。
6.抽象关系比较
	JavaScript 中<=是“不大于”的意思，即b <= a处理为!(a > b)，同理 a >= b处理为!(b < a)。
	比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。
	如果比较双方都是字符串，则比较两个字符串对应的字符编码值




	toString()
		数字，字符串，布尔值都有toString()方法，调用时会用Number(),String(),Boolean()封装为对象,再调用对应的原生原型对象的toString()。
		如果对象有自己的toString()方法，就调用该方法并使用其返回值。
		null 和undefined 值没有toString方法
		对普通对象来说，默认的toString()返回内部属性[[Class]] 的值，如"[object Object]"。
		在调用数值的 toString() 方法时，可以传递一个参数：输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数，toString() 可以输出任意有效进制格式表示的字符串值。
		数组的默认toString()方法经过了重新定义，将所有单元字符串化以后再用", " 连接起来,如果数组中的某一项的值是 null 或者undefined，那么该值在toString() 方法返回的结果中以空字符串表示。
		Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM 或PM，但不会包含时区信息。而 toString() 方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。
		RegExp 实例继承的toLocaleString() 和toString() 方法都会返回正则表达式的字面量
		每个函数继承的toLocaleString()和toString() 方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。
		Boolean类型的实例重写了 toString()方法，返回字符串"true"和"false"

	valueOf()
	
	对象到数字的ToPrimitive抽象操作
		首先判断是否有valueOf()方法并返回基本类型值，是的话调用valueOf()方法，
		否则判断是否有toString()方法并返回基本类型值，是的话调用toString()方法，
		否则产生TypeError 错误
	对象到字符串的ToPrimitive抽象操作
		首先判断是否有toString()方法并返回基本类型值，是的话调用toString()方法，
		否则判断是否有valueOf()方法并返回基本类型值，是的话调用valueOf()方法，
		否则产生TypeError 错误
	



来源：
	你不知道的JS（中）
	JavaScript高级程序设计